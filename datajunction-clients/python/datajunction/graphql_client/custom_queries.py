# Generated by ariadne-codegen

from typing import Any, Dict, List, Optional

from . import NodeType
from .custom_fields import (
    CatalogFields,
    DialectInfoFields,
    DimensionAttributeFields,
    EngineFields,
    GeneratedSQLFields,
    NodeConnectionFields,
    NodeFields,
    TagFields,
)
from .custom_typing_fields import GraphQLField
from .input_types import CubeDefinition, EngineSettings


class Query:
    @classmethod
    def list_catalogs(cls) -> CatalogFields:
        return CatalogFields(field_name="listCatalogs")

    @classmethod
    def list_engines(cls) -> EngineFields:
        return EngineFields(field_name="listEngines")

    @classmethod
    def list_dialects(cls) -> DialectInfoFields:
        return DialectInfoFields(field_name="listDialects")

    @classmethod
    def find_nodes(
        cls,
        *,
        fragment: Optional[str] = None,
        names: Optional[List[str]] = None,
        node_types: Optional[List[NodeType]] = None,
        tags: Optional[List[str]] = None,
        limit: Optional[int] = None
    ) -> NodeFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "fragment": {"type": "String", "value": fragment},
            "names": {"type": "[String!]", "value": names},
            "nodeTypes": {"type": "[NodeType!]", "value": node_types},
            "tags": {"type": "[String!]", "value": tags},
            "limit": {"type": "Int", "value": limit},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeFields(field_name="findNodes", arguments=cleared_arguments)

    @classmethod
    def find_nodes_paginated(
        cls,
        *,
        fragment: Optional[str] = None,
        names: Optional[List[str]] = None,
        node_types: Optional[List[NodeType]] = None,
        tags: Optional[List[str]] = None,
        edited_by: Optional[str] = None,
        namespace: Optional[str] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        limit: Optional[int] = None
    ) -> NodeConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "fragment": {"type": "String", "value": fragment},
            "names": {"type": "[String!]", "value": names},
            "nodeTypes": {"type": "[NodeType!]", "value": node_types},
            "tags": {"type": "[String!]", "value": tags},
            "editedBy": {"type": "String", "value": edited_by},
            "namespace": {"type": "String", "value": namespace},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "limit": {"type": "Int", "value": limit},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeConnectionFields(
            field_name="findNodesPaginated", arguments=cleared_arguments
        )

    @classmethod
    def common_dimensions(
        cls, *, nodes: Optional[List[str]] = None
    ) -> DimensionAttributeFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "nodes": {"type": "[String!]", "value": nodes}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DimensionAttributeFields(
            field_name="commonDimensions", arguments=cleared_arguments
        )

    @classmethod
    def downstream_nodes(
        cls, node_name: str, *, node_type: Optional[NodeType] = None
    ) -> NodeFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "nodeName": {"type": "String!", "value": node_name},
            "nodeType": {"type": "NodeType", "value": node_type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeFields(field_name="downstreamNodes", arguments=cleared_arguments)

    @classmethod
    def measures_sql(
        cls,
        cube: CubeDefinition,
        use_materialized: bool,
        include_all_columns: bool,
        preaggregate: bool,
        *,
        engine: Optional[EngineSettings] = None
    ) -> GeneratedSQLFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "cube": {"type": "CubeDefinition!", "value": cube},
            "engine": {"type": "EngineSettings", "value": engine},
            "useMaterialized": {"type": "Boolean!", "value": use_materialized},
            "includeAllColumns": {"type": "Boolean!", "value": include_all_columns},
            "preaggregate": {"type": "Boolean!", "value": preaggregate},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GeneratedSQLFields(field_name="measuresSql", arguments=cleared_arguments)

    @classmethod
    def list_tags(
        cls,
        *,
        tag_names: Optional[List[str]] = None,
        tag_types: Optional[List[str]] = None
    ) -> TagFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "tagNames": {"type": "[String!]", "value": tag_names},
            "tagTypes": {"type": "[String!]", "value": tag_types},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TagFields(field_name="listTags", arguments=cleared_arguments)

    @classmethod
    def list_tag_types(cls) -> GraphQLField:
        return GraphQLField(field_name="listTagTypes")
