# Generated by ariadne-codegen

from typing import Any, Dict, List, Optional, Union

from .base_operation import GraphQLField
from .custom_typing_fields import (
    AggregationRuleGraphQLField,
    AttributeGraphQLField,
    AttributeTypeNameGraphQLField,
    AvailabilityStateGraphQLField,
    BackfillGraphQLField,
    CatalogGraphQLField,
    ColumnGraphQLField,
    ColumnMetadataGraphQLField,
    DecomposedMetricGraphQLField,
    DialectInfoGraphQLField,
    DimensionAttributeGraphQLField,
    DimensionLinkGraphQLField,
    DJErrorGraphQLField,
    EngineGraphQLField,
    GeneratedSQLGraphQLField,
    MaterializationConfigGraphQLField,
    MetricComponentGraphQLField,
    MetricMetadataGraphQLField,
    NodeConnectionGraphQLField,
    NodeEdgeGraphQLField,
    NodeGraphQLField,
    NodeNameGraphQLField,
    NodeRevisionGraphQLField,
    PageInfoGraphQLField,
    PartitionAvailabilityGraphQLField,
    PartitionBackfillGraphQLField,
    PartitionGraphQLField,
    SemanticEntityGraphQLField,
    TagBaseGraphQLField,
    TagGraphQLField,
    UnitGraphQLField,
    UserGraphQLField,
)


class AggregationRuleFields(GraphQLField):
    type: "AggregationRuleGraphQLField" = AggregationRuleGraphQLField("type")
    level: "AggregationRuleGraphQLField" = AggregationRuleGraphQLField("level")

    def fields(
        self, *subfields: AggregationRuleGraphQLField
    ) -> "AggregationRuleFields":
        """Subfields should come from the AggregationRuleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregationRuleFields":
        self._alias = alias
        return self


class AttributeFields(GraphQLField):
    @classmethod
    def attribute_type(cls) -> "AttributeTypeNameFields":
        return AttributeTypeNameFields("attribute_type")

    def fields(
        self, *subfields: Union[AttributeGraphQLField, "AttributeTypeNameFields"]
    ) -> "AttributeFields":
        """Subfields should come from the AttributeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AttributeFields":
        self._alias = alias
        return self


class AttributeTypeNameFields(GraphQLField):
    namespace: "AttributeTypeNameGraphQLField" = AttributeTypeNameGraphQLField(
        "namespace"
    )
    name: "AttributeTypeNameGraphQLField" = AttributeTypeNameGraphQLField("name")

    def fields(
        self, *subfields: AttributeTypeNameGraphQLField
    ) -> "AttributeTypeNameFields":
        """Subfields should come from the AttributeTypeNameFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AttributeTypeNameFields":
        self._alias = alias
        return self


class AvailabilityStateFields(GraphQLField):
    catalog: "AvailabilityStateGraphQLField" = AvailabilityStateGraphQLField("catalog")
    schema: "AvailabilityStateGraphQLField" = AvailabilityStateGraphQLField("schema_")
    table: "AvailabilityStateGraphQLField" = AvailabilityStateGraphQLField("table")
    valid_through_ts: "AvailabilityStateGraphQLField" = AvailabilityStateGraphQLField(
        "validThroughTs"
    )
    url: "AvailabilityStateGraphQLField" = AvailabilityStateGraphQLField("url")
    categorical_partitions: "AvailabilityStateGraphQLField" = (
        AvailabilityStateGraphQLField("categoricalPartitions")
    )
    temporal_partitions: "AvailabilityStateGraphQLField" = (
        AvailabilityStateGraphQLField("temporalPartitions")
    )
    min_temporal_partition: "AvailabilityStateGraphQLField" = (
        AvailabilityStateGraphQLField("minTemporalPartition")
    )
    max_temporal_partition: "AvailabilityStateGraphQLField" = (
        AvailabilityStateGraphQLField("maxTemporalPartition")
    )

    @classmethod
    def partitions(cls) -> "PartitionAvailabilityFields":
        return PartitionAvailabilityFields("partitions")

    def fields(
        self,
        *subfields: Union[AvailabilityStateGraphQLField, "PartitionAvailabilityFields"]
    ) -> "AvailabilityStateFields":
        """Subfields should come from the AvailabilityStateFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AvailabilityStateFields":
        self._alias = alias
        return self


class BackfillFields(GraphQLField):
    @classmethod
    def spec(cls) -> "PartitionBackfillFields":
        return PartitionBackfillFields("spec")

    urls: "BackfillGraphQLField" = BackfillGraphQLField("urls")

    def fields(
        self, *subfields: Union[BackfillGraphQLField, "PartitionBackfillFields"]
    ) -> "BackfillFields":
        """Subfields should come from the BackfillFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BackfillFields":
        self._alias = alias
        return self


class CatalogFields(GraphQLField):
    name: "CatalogGraphQLField" = CatalogGraphQLField("name")

    @classmethod
    def engines(cls) -> "EngineFields":
        return EngineFields("engines")

    def fields(
        self, *subfields: Union[CatalogGraphQLField, "EngineFields"]
    ) -> "CatalogFields":
        """Subfields should come from the CatalogFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CatalogFields":
        self._alias = alias
        return self


class ColumnFields(GraphQLField):
    name: "ColumnGraphQLField" = ColumnGraphQLField("name")
    display_name: "ColumnGraphQLField" = ColumnGraphQLField("displayName")
    type: "ColumnGraphQLField" = ColumnGraphQLField("type")

    @classmethod
    def attributes(cls) -> "AttributeFields":
        return AttributeFields("attributes")

    @classmethod
    def dimension(cls) -> "NodeNameFields":
        return NodeNameFields("dimension")

    @classmethod
    def partition(cls) -> "PartitionFields":
        return PartitionFields("partition")

    def fields(
        self,
        *subfields: Union[
            ColumnGraphQLField, "AttributeFields", "NodeNameFields", "PartitionFields"
        ]
    ) -> "ColumnFields":
        """Subfields should come from the ColumnFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ColumnFields":
        self._alias = alias
        return self


class ColumnMetadataFields(GraphQLField):
    name: "ColumnMetadataGraphQLField" = ColumnMetadataGraphQLField("name")
    type: "ColumnMetadataGraphQLField" = ColumnMetadataGraphQLField("type")

    @classmethod
    def semantic_entity(cls) -> "SemanticEntityFields":
        return SemanticEntityFields("semantic_entity")

    semantic_type: "ColumnMetadataGraphQLField" = ColumnMetadataGraphQLField(
        "semanticType"
    )

    def fields(
        self, *subfields: Union[ColumnMetadataGraphQLField, "SemanticEntityFields"]
    ) -> "ColumnMetadataFields":
        """Subfields should come from the ColumnMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ColumnMetadataFields":
        self._alias = alias
        return self


class DJErrorFields(GraphQLField):
    code: "DJErrorGraphQLField" = DJErrorGraphQLField("code")
    message: "DJErrorGraphQLField" = DJErrorGraphQLField("message")
    context: "DJErrorGraphQLField" = DJErrorGraphQLField("context")

    def fields(self, *subfields: DJErrorGraphQLField) -> "DJErrorFields":
        """Subfields should come from the DJErrorFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DJErrorFields":
        self._alias = alias
        return self


class DecomposedMetricFields(GraphQLField):
    @classmethod
    def components(cls) -> "MetricComponentFields":
        return MetricComponentFields("components")

    derived_query: "DecomposedMetricGraphQLField" = DecomposedMetricGraphQLField(
        "derivedQuery"
    )
    derived_expression: "DecomposedMetricGraphQLField" = DecomposedMetricGraphQLField(
        "derivedExpression"
    )

    def fields(
        self, *subfields: Union[DecomposedMetricGraphQLField, "MetricComponentFields"]
    ) -> "DecomposedMetricFields":
        """Subfields should come from the DecomposedMetricFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DecomposedMetricFields":
        self._alias = alias
        return self


class DialectInfoFields(GraphQLField):
    name: "DialectInfoGraphQLField" = DialectInfoGraphQLField("name")
    plugin_class: "DialectInfoGraphQLField" = DialectInfoGraphQLField("pluginClass")

    def fields(self, *subfields: DialectInfoGraphQLField) -> "DialectInfoFields":
        """Subfields should come from the DialectInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DialectInfoFields":
        self._alias = alias
        return self


class DimensionAttributeFields(GraphQLField):
    name: "DimensionAttributeGraphQLField" = DimensionAttributeGraphQLField("name")
    attribute: "DimensionAttributeGraphQLField" = DimensionAttributeGraphQLField(
        "attribute"
    )
    role: "DimensionAttributeGraphQLField" = DimensionAttributeGraphQLField("role")
    properties: "DimensionAttributeGraphQLField" = DimensionAttributeGraphQLField(
        "properties"
    )
    type: "DimensionAttributeGraphQLField" = DimensionAttributeGraphQLField("type")

    @classmethod
    def dimension_node(cls) -> "NodeFields":
        return NodeFields("dimension_node")

    @classmethod
    def dimension_node(cls) -> "NodeFields":
        return NodeFields("dimension_node")

    def fields(
        self, *subfields: Union[DimensionAttributeGraphQLField, "NodeFields"]
    ) -> "DimensionAttributeFields":
        """Subfields should come from the DimensionAttributeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionAttributeFields":
        self._alias = alias
        return self


class DimensionLinkFields(GraphQLField):
    @classmethod
    def dimension(cls) -> "NodeNameFields":
        return NodeNameFields("dimension")

    join_type: "DimensionLinkGraphQLField" = DimensionLinkGraphQLField("joinType")
    join_sql: "DimensionLinkGraphQLField" = DimensionLinkGraphQLField("joinSql")
    join_cardinality: "DimensionLinkGraphQLField" = DimensionLinkGraphQLField(
        "joinCardinality"
    )
    role: "DimensionLinkGraphQLField" = DimensionLinkGraphQLField("role")
    foreign_keys: "DimensionLinkGraphQLField" = DimensionLinkGraphQLField("foreignKeys")

    def fields(
        self, *subfields: Union[DimensionLinkGraphQLField, "NodeNameFields"]
    ) -> "DimensionLinkFields":
        """Subfields should come from the DimensionLinkFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionLinkFields":
        self._alias = alias
        return self


class EngineFields(GraphQLField):
    name: "EngineGraphQLField" = EngineGraphQLField("name")
    version: "EngineGraphQLField" = EngineGraphQLField("version")
    uri: "EngineGraphQLField" = EngineGraphQLField("uri")
    dialect: "EngineGraphQLField" = EngineGraphQLField("dialect")

    def fields(self, *subfields: EngineGraphQLField) -> "EngineFields":
        """Subfields should come from the EngineFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EngineFields":
        self._alias = alias
        return self


class GeneratedSQLFields(GraphQLField):
    @classmethod
    def node(cls) -> "NodeFields":
        return NodeFields("node")

    sql: "GeneratedSQLGraphQLField" = GeneratedSQLGraphQLField("sql")

    @classmethod
    def columns(cls) -> "ColumnMetadataFields":
        return ColumnMetadataFields("columns")

    dialect: "GeneratedSQLGraphQLField" = GeneratedSQLGraphQLField("dialect")
    upstream_tables: "GeneratedSQLGraphQLField" = GeneratedSQLGraphQLField(
        "upstreamTables"
    )

    @classmethod
    def errors(cls) -> "DJErrorFields":
        return DJErrorFields("errors")

    def fields(
        self,
        *subfields: Union[
            GeneratedSQLGraphQLField,
            "ColumnMetadataFields",
            "DJErrorFields",
            "NodeFields",
        ]
    ) -> "GeneratedSQLFields":
        """Subfields should come from the GeneratedSQLFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneratedSQLFields":
        self._alias = alias
        return self


class MaterializationConfigFields(GraphQLField):
    name: "MaterializationConfigGraphQLField" = MaterializationConfigGraphQLField(
        "name"
    )
    config: "MaterializationConfigGraphQLField" = MaterializationConfigGraphQLField(
        "config"
    )
    schedule: "MaterializationConfigGraphQLField" = MaterializationConfigGraphQLField(
        "schedule"
    )
    job: "MaterializationConfigGraphQLField" = MaterializationConfigGraphQLField("job")

    @classmethod
    def backfills(cls) -> "BackfillFields":
        return BackfillFields("backfills")

    strategy: "MaterializationConfigGraphQLField" = MaterializationConfigGraphQLField(
        "strategy"
    )

    def fields(
        self, *subfields: Union[MaterializationConfigGraphQLField, "BackfillFields"]
    ) -> "MaterializationConfigFields":
        """Subfields should come from the MaterializationConfigFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MaterializationConfigFields":
        self._alias = alias
        return self


class MetricComponentFields(GraphQLField):
    name: "MetricComponentGraphQLField" = MetricComponentGraphQLField("name")
    expression: "MetricComponentGraphQLField" = MetricComponentGraphQLField(
        "expression"
    )
    aggregation: "MetricComponentGraphQLField" = MetricComponentGraphQLField(
        "aggregation"
    )

    @classmethod
    def rule(cls) -> "AggregationRuleFields":
        return AggregationRuleFields("rule")

    def fields(
        self, *subfields: Union[MetricComponentGraphQLField, "AggregationRuleFields"]
    ) -> "MetricComponentFields":
        """Subfields should come from the MetricComponentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricComponentFields":
        self._alias = alias
        return self


class MetricMetadataFields(GraphQLField):
    direction: "MetricMetadataGraphQLField" = MetricMetadataGraphQLField("direction")

    @classmethod
    def unit(cls) -> "UnitFields":
        return UnitFields("unit")

    significant_digits: "MetricMetadataGraphQLField" = MetricMetadataGraphQLField(
        "significantDigits"
    )
    min_decimal_exponent: "MetricMetadataGraphQLField" = MetricMetadataGraphQLField(
        "minDecimalExponent"
    )
    max_decimal_exponent: "MetricMetadataGraphQLField" = MetricMetadataGraphQLField(
        "maxDecimalExponent"
    )
    expression: "MetricMetadataGraphQLField" = MetricMetadataGraphQLField("expression")
    incompatible_druid_functions: "MetricMetadataGraphQLField" = (
        MetricMetadataGraphQLField("incompatibleDruidFunctions")
    )

    def fields(
        self, *subfields: Union[MetricMetadataGraphQLField, "UnitFields"]
    ) -> "MetricMetadataFields":
        """Subfields should come from the MetricMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MetricMetadataFields":
        self._alias = alias
        return self


class NodeFields(GraphQLField):
    id: "NodeGraphQLField" = NodeGraphQLField("id")
    name: "NodeGraphQLField" = NodeGraphQLField("name")
    type: "NodeGraphQLField" = NodeGraphQLField("type")
    current_version: "NodeGraphQLField" = NodeGraphQLField("currentVersion")
    created_at: "NodeGraphQLField" = NodeGraphQLField("createdAt")
    deactivated_at: "NodeGraphQLField" = NodeGraphQLField("deactivatedAt")

    @classmethod
    def current(cls) -> "NodeRevisionFields":
        return NodeRevisionFields("current")

    @classmethod
    def revisions(cls) -> "NodeRevisionFields":
        return NodeRevisionFields("revisions")

    @classmethod
    def tags(cls) -> "TagBaseFields":
        return TagBaseFields("tags")

    @classmethod
    def created_by(cls) -> "UserFields":
        return UserFields("created_by")

    edited_by: "NodeGraphQLField" = NodeGraphQLField("editedBy")

    def fields(
        self,
        *subfields: Union[
            NodeGraphQLField, "NodeRevisionFields", "TagBaseFields", "UserFields"
        ]
    ) -> "NodeFields":
        """Subfields should come from the NodeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeFields":
        self._alias = alias
        return self


class NodeConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "NodeEdgeFields":
        return NodeEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            NodeConnectionGraphQLField, "NodeEdgeFields", "PageInfoFields"
        ]
    ) -> "NodeConnectionFields":
        """Subfields should come from the NodeConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeConnectionFields":
        self._alias = alias
        return self


class NodeEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "NodeFields":
        return NodeFields("node")

    def fields(
        self, *subfields: Union[NodeEdgeGraphQLField, "NodeFields"]
    ) -> "NodeEdgeFields":
        """Subfields should come from the NodeEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeEdgeFields":
        self._alias = alias
        return self


class NodeNameFields(GraphQLField):
    name: "NodeNameGraphQLField" = NodeNameGraphQLField("name")

    def fields(self, *subfields: NodeNameGraphQLField) -> "NodeNameFields":
        """Subfields should come from the NodeNameFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeNameFields":
        self._alias = alias
        return self


class NodeRevisionFields(GraphQLField):
    id: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("id")
    type: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("type")
    name: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("name")
    display_name: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("displayName")
    version: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("version")
    status: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("status")
    mode: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("mode")
    description: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("description")
    updated_at: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("updatedAt")
    custom_metadata: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField(
        "customMetadata"
    )
    query: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("query")

    @classmethod
    def dimension_links(cls) -> "DimensionLinkFields":
        return DimensionLinkFields("dimension_links")

    @classmethod
    def parents(cls) -> "NodeNameFields":
        return NodeNameFields("parents")

    @classmethod
    def availability(cls) -> "AvailabilityStateFields":
        return AvailabilityStateFields("availability")

    @classmethod
    def materializations(cls) -> "MaterializationConfigFields":
        return MaterializationConfigFields("materializations")

    schema: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("schema_")
    table: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("table")

    @classmethod
    def required_dimensions(cls) -> "ColumnFields":
        return ColumnFields("required_dimensions")

    @classmethod
    def catalog(cls) -> "CatalogFields":
        return CatalogFields("catalog")

    @classmethod
    def columns(cls, *, attributes: Optional[List[str]] = None) -> "ColumnFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "attributes": {"type": "[String!]", "value": attributes}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ColumnFields("columns", arguments=cleared_arguments)

    primary_key: "NodeRevisionGraphQLField" = NodeRevisionGraphQLField("primaryKey")

    @classmethod
    def metric_metadata(cls) -> "MetricMetadataFields":
        return MetricMetadataFields("metric_metadata")

    @classmethod
    def extracted_measures(cls) -> "DecomposedMetricFields":
        return DecomposedMetricFields("extracted_measures")

    @classmethod
    def cube_metrics(cls) -> "NodeRevisionFields":
        return NodeRevisionFields("cube_metrics")

    @classmethod
    def cube_dimensions(cls) -> "DimensionAttributeFields":
        return DimensionAttributeFields("cube_dimensions")

    def fields(
        self,
        *subfields: Union[
            NodeRevisionGraphQLField,
            "AvailabilityStateFields",
            "CatalogFields",
            "ColumnFields",
            "DecomposedMetricFields",
            "DimensionAttributeFields",
            "DimensionLinkFields",
            "MaterializationConfigFields",
            "MetricMetadataFields",
            "NodeNameFields",
            "NodeRevisionFields",
        ]
    ) -> "NodeRevisionFields":
        """Subfields should come from the NodeRevisionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeRevisionFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    has_next_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")
    has_prev_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasPrevPage")
    start_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("startCursor")
    end_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("endCursor")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class PartitionFields(GraphQLField):
    type: "PartitionGraphQLField" = PartitionGraphQLField("type_")
    format: "PartitionGraphQLField" = PartitionGraphQLField("format")
    granularity: "PartitionGraphQLField" = PartitionGraphQLField("granularity")
    expression: "PartitionGraphQLField" = PartitionGraphQLField("expression")

    def fields(self, *subfields: PartitionGraphQLField) -> "PartitionFields":
        """Subfields should come from the PartitionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PartitionFields":
        self._alias = alias
        return self


class PartitionAvailabilityFields(GraphQLField):
    min_temporal_partition: "PartitionAvailabilityGraphQLField" = (
        PartitionAvailabilityGraphQLField("minTemporalPartition")
    )
    max_temporal_partition: "PartitionAvailabilityGraphQLField" = (
        PartitionAvailabilityGraphQLField("maxTemporalPartition")
    )
    value: "PartitionAvailabilityGraphQLField" = PartitionAvailabilityGraphQLField(
        "value"
    )
    valid_through_ts: "PartitionAvailabilityGraphQLField" = (
        PartitionAvailabilityGraphQLField("validThroughTs")
    )

    def fields(
        self, *subfields: PartitionAvailabilityGraphQLField
    ) -> "PartitionAvailabilityFields":
        """Subfields should come from the PartitionAvailabilityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PartitionAvailabilityFields":
        self._alias = alias
        return self


class PartitionBackfillFields(GraphQLField):
    column_name: "PartitionBackfillGraphQLField" = PartitionBackfillGraphQLField(
        "columnName"
    )
    values: "PartitionBackfillGraphQLField" = PartitionBackfillGraphQLField("values")
    range: "PartitionBackfillGraphQLField" = PartitionBackfillGraphQLField("range")

    def fields(
        self, *subfields: PartitionBackfillGraphQLField
    ) -> "PartitionBackfillFields":
        """Subfields should come from the PartitionBackfillFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PartitionBackfillFields":
        self._alias = alias
        return self


class SemanticEntityFields(GraphQLField):
    name: "SemanticEntityGraphQLField" = SemanticEntityGraphQLField("name")
    node: "SemanticEntityGraphQLField" = SemanticEntityGraphQLField("node")
    column: "SemanticEntityGraphQLField" = SemanticEntityGraphQLField("column")

    def fields(self, *subfields: SemanticEntityGraphQLField) -> "SemanticEntityFields":
        """Subfields should come from the SemanticEntityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SemanticEntityFields":
        self._alias = alias
        return self


class TagFields(GraphQLField):
    name: "TagGraphQLField" = TagGraphQLField("name")
    tag_type: "TagGraphQLField" = TagGraphQLField("tagType")
    description: "TagGraphQLField" = TagGraphQLField("description")
    display_name: "TagGraphQLField" = TagGraphQLField("displayName")
    tag_metadata: "TagGraphQLField" = TagGraphQLField("tagMetadata")

    @classmethod
    def nodes(cls) -> "NodeFields":
        return NodeFields("nodes")

    def fields(self, *subfields: Union[TagGraphQLField, "NodeFields"]) -> "TagFields":
        """Subfields should come from the TagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TagFields":
        self._alias = alias
        return self


class TagBaseFields(GraphQLField):
    name: "TagBaseGraphQLField" = TagBaseGraphQLField("name")
    tag_type: "TagBaseGraphQLField" = TagBaseGraphQLField("tagType")
    description: "TagBaseGraphQLField" = TagBaseGraphQLField("description")
    display_name: "TagBaseGraphQLField" = TagBaseGraphQLField("displayName")
    tag_metadata: "TagBaseGraphQLField" = TagBaseGraphQLField("tagMetadata")

    def fields(self, *subfields: TagBaseGraphQLField) -> "TagBaseFields":
        """Subfields should come from the TagBaseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TagBaseFields":
        self._alias = alias
        return self


class UnitFields(GraphQLField):
    name: "UnitGraphQLField" = UnitGraphQLField("name")
    label: "UnitGraphQLField" = UnitGraphQLField("label")
    category: "UnitGraphQLField" = UnitGraphQLField("category")
    abbreviation: "UnitGraphQLField" = UnitGraphQLField("abbreviation")

    def fields(self, *subfields: UnitGraphQLField) -> "UnitFields":
        """Subfields should come from the UnitFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UnitFields":
        self._alias = alias
        return self


class UserFields(GraphQLField):
    id: "UserGraphQLField" = UserGraphQLField("id")
    username: "UserGraphQLField" = UserGraphQLField("username")
    email: "UserGraphQLField" = UserGraphQLField("email")
    name: "UserGraphQLField" = UserGraphQLField("name")
    oauth_provider: "UserGraphQLField" = UserGraphQLField("oauthProvider")
    is_admin: "UserGraphQLField" = UserGraphQLField("isAdmin")

    def fields(self, *subfields: UserGraphQLField) -> "UserFields":
        """Subfields should come from the UserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserFields":
        self._alias = alias
        return self
